"""Section loader for filtering parsed markdown data by hierarchical sections.

This module provides functionality to load parsed markdown data (from parquet files
or DataFrames) and filter it based on section headers using the `parents` column.
Supports exact matching, case-insensitive matching, and fuzzy matching using RapidFuzz.
"""

from pathlib import Path
from typing import Literal, Optional, Union

import pandas as pd

try:
    from rapidfuzz import fuzz
    RAPIDFUZZ_AVAILABLE = True
except ImportError:
    RAPIDFUZZ_AVAILABLE = False


class MarkdownSectionLoader:
    """Loader for filtering parsed markdown data by section headers.
    
    This class provides methods to load parsed markdown data (generated by
    `batch_process_markdown_dataframe()`) and filter it based on section headers
    found in the `parents` column. Supports multiple matching strategies:
    - Exact matching (default)
    - Case-insensitive matching
    - Fuzzy matching using RapidFuzz
    
    Example:
        >>> # Load from file and filter by section
        >>> loader = MarkdownSectionLoader("parsed_data.parquet")
        >>> df_rfv = loader.filter_sections("REASON FOR VISIT")
        
        >>> # Load from DataFrame with case-insensitive matching
        >>> loader = MarkdownSectionLoader(df)
        >>> df_hist = loader.filter_sections(
        ...     ["history", "past medical history"],
        ...     match_type="case_insensitive"
        ... )
        
        >>> # Fuzzy matching with custom threshold
        >>> df_fuzzy = loader.filter_sections(
        ...     "REASON FOR VISIT",
        ...     match_type="fuzzy",
        ...     fuzzy_threshold=85,
        ...     output="filtered_sections.parquet"
        ... )
    """
    
    def __init__(
        self,
        data: Union[str, Path, pd.DataFrame],
    ) -> None:
        """Initializes the MarkdownSectionLoader.
        
        Args:
            data: Either a file path (str or Path) to a parquet file containing
                parsed markdown data, or a pandas DataFrame with the parsed data.
                Expected DataFrame schema: id, start_line, level, length, parents,
                parent_types, content (plus any metadata columns).
        
        Raises:
            FileNotFoundError: If data is a file path and the file doesn't exist.
            ValueError: If data is a DataFrame but missing required 'parents' column.
        """
        if isinstance(data, (str, Path)):
            # Load from file
            filepath = Path(data)
            if not filepath.exists():
                raise FileNotFoundError(f"File not found: {filepath}")
            
            self.df = pd.read_parquet(filepath)
            self.source_path = filepath
        elif isinstance(data, pd.DataFrame):
            # Use provided DataFrame
            self.df = data.copy()
            self.source_path = None
        else:
            raise TypeError(
                f"data must be a file path (str/Path) or DataFrame, got {type(data)}"
            )
        
        # Validate required column
        if 'parents' not in self.df.columns:
            raise ValueError(
                f"DataFrame must contain 'parents' column. "
                f"Available columns: {list(self.df.columns)}"
            )
    
    def _match_exact(self, parents_list: list[str], section: str) -> bool:
        """Checks if section matches the last parent using exact matching.
        
        Args:
            parents_list: List of parent section headers.
            section: Section header to match.
            
        Returns:
            True if section exactly matches the last parent, False otherwise.
        """
        return len(parents_list) > 0 and parents_list[-1] == section
    
    def _match_case_insensitive(self, parents_list: list[str], section: str) -> bool:
        """Checks if section matches the last parent using case-insensitive matching.
        
        Args:
            parents_list: List of parent section headers.
            section: Section header to match.
            
        Returns:
            True if section matches the last parent (case-insensitive), False otherwise.
        """
        if len(parents_list) == 0:
            return False
        return parents_list[-1].lower() == section.lower()
    
    def _match_fuzzy(
        self,
        parents_list: list[str],
        section: str,
        threshold: int
    ) -> bool:
        """Checks if section matches the last parent using fuzzy matching.
        
        Uses RapidFuzz's ratio comparison for fuzzy string matching.
        
        Args:
            parents_list: List of parent section headers.
            section: Section header to match.
            threshold: Minimum similarity score (0-100) to consider a match.
            
        Returns:
            True if the last parent has similarity >= threshold, False otherwise.
        """
        if not RAPIDFUZZ_AVAILABLE:
            raise ImportError(
                "RapidFuzz is required for fuzzy matching. "
                "Install it with: pip install rapidfuzz"
            )
        
        if len(parents_list) == 0:
            return False
        
        return fuzz.ratio(section, parents_list[-1]) >= threshold
    
    def filter_sections(
        self,
        sections: Union[str, list[str]],
        match_type: Literal["exact", "case_insensitive", "fuzzy"] = "exact",
        fuzzy_threshold: int = 80,
        output: Optional[Union[str, Path]] = None,
    ) -> pd.DataFrame:
        """Filters the DataFrame to rows where specified sections appear in parents.
        
        This method filters the loaded DataFrame to include only rows where at least
        one of the specified section headers matches the last item in the `parents` column
        (i.e., the immediate parent header). Multiple sections are combined using OR logic.
        
        Args:
            sections: Single section header (str) or list of section headers to filter by.
            match_type: Matching strategy to use:
                - "exact": Exact string matching (default)
                - "case_insensitive": Case-insensitive string matching
                - "fuzzy": Fuzzy string matching using RapidFuzz
            fuzzy_threshold: Minimum similarity score (0-100) for fuzzy matching.
                Only used when match_type="fuzzy". Defaults to 80.
            output: Optional output file path. If provided, saves the filtered
                DataFrame to this path as a parquet file. Defaults to None.
        
        Returns:
            Filtered DataFrame containing only rows where at least one of the
            specified sections appears in the parents hierarchy.
        
        Raises:
            ValueError: If match_type is not one of the supported values.
            ImportError: If match_type="fuzzy" but rapidfuzz is not installed.
        
        Example:
            >>> loader = MarkdownSectionLoader("parsed_data.parquet")
            >>> # Single section, exact match
            >>> df1 = loader.filter_sections("REASON FOR VISIT")
            >>> # Multiple sections, case-insensitive
            >>> df2 = loader.filter_sections(
            ...     ["history", "medical history"],
            ...     match_type="case_insensitive"
            ... )
            >>> # Fuzzy match with custom threshold
            >>> df3 = loader.filter_sections(
            ...     "REASON FOR VISIT",
            ...     match_type="fuzzy",
            ...     fuzzy_threshold=85,
            ...     output="filtered.parquet"
            ... )
        """
        # Normalize sections to list
        if isinstance(sections, str):
            sections = [sections]
        
        # Validate match_type
        valid_match_types = {"exact", "case_insensitive", "fuzzy"}
        if match_type not in valid_match_types:
            raise ValueError(
                f"match_type must be one of {valid_match_types}, got '{match_type}'"
            )
        
        # Validate fuzzy threshold
        if match_type == "fuzzy":
            if not isinstance(fuzzy_threshold, int) or not (0 <= fuzzy_threshold <= 100):
                raise ValueError(
                    f"fuzzy_threshold must be an integer between 0 and 100, "
                    f"got {fuzzy_threshold}"
                )
        
        # Select matching function
        if match_type == "exact":
            match_func = self._match_exact
        elif match_type == "case_insensitive":
            match_func = self._match_case_insensitive
        else:  # fuzzy
            match_func = lambda parents_list, section: self._match_fuzzy(
                parents_list, section, fuzzy_threshold
            )
        
        # Filter DataFrame: row matches if ANY section matches ANY parent
        filtered_df = self.df[
            self.df['parents'].apply(
                lambda parents_list: any(
                    match_func(parents_list, section)
                    for section in sections
                )
            )
        ].copy()
        
        # Save to output if specified
        if output is not None:
            output_path = Path(output)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            filtered_df.to_parquet(output_path, index=False)
        
        return filtered_df
